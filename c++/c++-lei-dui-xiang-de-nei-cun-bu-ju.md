# C++ 类对象的内存布局

c++ 类里面有成员函数，成员变量，还分为动态类型和静态类型等，那么 c++ 类 new 出来的对象内存布局是什么样的呢。

首先 c++ 标准没有硬性规定对象的内存布局，这通常由编译器和 ABI (Application Binary Interface) 来决定。在主流编译器上（gcc Clang MSVC），都遵循着一些共同的事实上的标准。

## 1 只有非静态数据成员的类

对象的内存布局就是其非静态数据成员按照声明顺序依次排列。

关键点：内存对齐

为了让 CPU 更高效地访问数据，编译器会对成员进行内存对齐。每个数据类型都有一个对齐的要求。编译器会在成员之间插入一些空白字符，以确保每个成员的其实地址都是其对齐要求的整数倍。

```
class MyClass {
public:
    char a;
    int b;
    char c;
};

int main() {
    MyClass* c = new MyClass;
    c->a = 1;
    c->b = 2;
    c->c = 3;
    return 0;
}
```

实际布局

```
// 地址偏移
// +0   +1   +2   +3   +4   +5   +6   +7   +8   +9   +10  +11
// | a | pad| pad| pad|      b      | c | pad| pad| pad |
// +-------------------+-------------------+--------------------+
//   ^                   ^                   ^
//   a (1 字节)        b (4 字节)          c (1 字节)
```

1. `a` (char) 放在偏移量 0 处。
2. `b` (int) 需要 4 字节对齐，所以它的起始地址必须是 4 的倍数。编译器在 `a` 后面填充 3 个字节（padding），使得 `b` 从偏移量 4 开始。
3. `c` (char) 放在 `b` 之后，即偏移量 8 处。
4. 为了让整个 `MyClass` 对象在数组中也能正确对齐，对象自身的总大小也需要是其最严格成员（这里是 `int`，对齐要求为 4）的整数倍。所以，在 `c` 后面再填充 3 个字节，使得总大小为 12 字节。

因此 MyClass 一般是 12 个字节

<figure><img src="../.gitbook/assets/image (46).png" alt=""><figcaption></figcaption></figure>

## 2. 包含成员函数的类

* 非静态成员函数，存储在代码段，由类所有的对象共享。当你调用一个成员函数时，编译器会隐式地传递一个指向该对象的指针，这个指针就是 this
* 静态成员函数，同样存储在代码段。他不与任何对象关联，所以没有 this 指针。

## 3. 包含静态数据成员的类

```
class StaticDataClass {
public:
    int a;
    static int b = 1;
};
```

a\
d\`
