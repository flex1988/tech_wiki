# The Adaptive Radix Tree: ARTful Indexing for Main-Memory Databases

摘要: 主存容量已经涨到了一个能把大部分数据库放到RAM中的时代。对于内存数据库系统来说，索引的性能是一个关键的瓶颈点。传统的内存索引结构比如平衡二叉树在现代硬件上效率比较低，因为他们并没有利用好CPU的cache。哈希表，也经常用于主存索引，足够快，但只能提供点查询。

为了克服上面的缺点，我们在这里介绍一下ART，Adaptive Radix Tree (trie) 可以有效的作为主存的查询索引。他的查找性能被高度优化，只读搜索树，支持高效的插入和删除。同时ART通过动态的压缩内部节点使得他的空间使用率很高，解决了Radix Tree通常对于空间占用很高的问题。不但ART的性能可以和哈希表相媲美，他还把数据保存成了排序的格式，这可以让范围查询和前缀搜索更有效率。

## 1. 介绍

经过几十年主存容量的增加，即使是大型的事务数据库也能把索引放到RAM中。当大部分数据都被Cache了以后，传统的数据库系统就变成了CPU密集型的应用，因为他们他们花费了很多的努力来避免磁盘IO。这也引领了在主存数据库方面非常激烈的研究和商业行为，像H-Store/VoltDB，SAP HANA和HyPer。这些系统基于新硬件趋势和更快来优化。比如我们的系统HyPer，把事务编译成了机器码避免了Buffer管理，锁和同步机制消耗过多等问题。针对于OLTP的工作负载，生成的查询计划一般是顺序的索引操作。所以，索引的效率是性能的重要因素。

25年前，T-Tree作为一个内存索引结构被提出来。不幸的是，戏剧性的处理器架构重新渲染了 T-Tree，像其他的二叉树一样，在现代硬件上效率很低。原因是一直增长的CPU cache和主存的访问速度分道扬镳，通用的内存访问速度的假设也就过时了。B+Tree的变体比如cache敏感的B+Tree对于内存的cache更加友好，但是需要跟昂贵的更新代价。更严重的是，不管是二叉树还是B+Tree都被另一个CPU特性拖累：因为比较的结果不能被精准的预测，所以现代的CPU的流水线就很容易停顿，这会引起额外的延迟。

这些传统查找树的问题被最近的一些基于现代硬件架构的数据结构解决掉了。K路的查找树和Fast Architecture Sensitive Tree (FAST)用数据的层级并行（SIMD）实现了同时做多个比较。而且FAST用了一个利用cacheline和TLB优化的数据结构来避免cache miss。尽管这些优化的索引结构可以提高查询的效率，但不能支持增量更新。对于一个OLTP的数据库系统来说，持续的插入，更新和删除都是必要的，一个明显的方法就是类似差速器文件的机制，但这会引起额外的损失。

哈希表是另一个流行的主存索引结构。和查找树O(logn)的查找时间相比，哈希表只有O(1)的查找时间，所以在主存中更快。尽管如此，哈希表在数据库索引中用的并不多。一个原因是哈希表把key随机的散列开了，所以就只能支持点查询。另一个原因是哈希表不能很好的处理扩容，不需要需要额外的重新组织的内存和O(n)的复杂度。因此现在的系统面临一个不幸的取舍，在哈希表的快速点查询和相对来说慢一点的功能齐全的查找树之间。

第三种数据结构的类型，被称为trie，radix tree，prefix tree，digital search tree，在表1中。

![](<../.gitbook/assets/image (4).png>)

这些数据结构直接用key的数字描述来代替hashing或者key的比较。基本的思路和在字母排序的字典中查找很相似：单词的第一个字母可以用来跳转到所有的以这个字母为起始的位置。在电脑中，这个过程可以一直持续到找到这个查询的对象。作为这个过程的结果，所有的操作都有O(k)的复杂度，k是key的长度。在有超大数据集的时代，n比k增长的更快，有一个时间复杂度独立于n的查询是一个很有吸引力的事情。

在本文里，我们陈述了adaptive radix tree(ART)，这是一个快速的，空间效率高的内存索引结构，以及针对现在硬件做了专门的优化。当大部分radix tree都在基于一个全局的扇入扇出的参数做一个树的高度和空间使用效率的权衡时，ART适应了每个独立节点的描述，像图1那样。通过本地的适配了每个内部节点，他优化了全局的空间利用率同时能够有效的查询。为了效率和压缩数据，基于子节点的数量动态的选择了代表节点的一个很小的数字。两个额外的技巧，路径压缩和懒扩展，让ART能够更有效率的压缩内部节点来索引长key，以及减少树的高度。

radix tree一个非常有用的属性是key的顺序不是随机的；这些key是被按照字典序排列的。我们展示了这些典型的数据类型怎样被有效的排序，去支持所有的需要数据有序的操作（比如，范围查询，前缀搜索，top-k，最小，最大）。

本文做了下面的工作：

1. 我们开发了adaptive radix tree (ART)，一个快速和空间效率高的通用内存数据库系统的索引结构。
2. 我们证明每个key的空间的放大是52字节，即使是任意长的key。我们的试验显示，空间放大实际上更低，大约为每个key 8.1字节
3. 我们陈述了怎么把通用的数据类型存储到radix tree中，并且保持他们的顺序
4. 我们试验评估了ART和别的主存索引结构，包括大部分的查找树
5. 通过把ART集成到HyPer的主存数据库系统中，我们跑了TPC-C benchmark，我们证明了他在现实的数据库系统中特别牛逼的端到端性能。

本文的后面是这样组织的。下一章会讨论有关系的工作，第三章会展示adaptive radix tree和分析他的空间放大。第四章我们介绍了二进制比较Key的含义，以及怎么把通用的类型转为这种key。第五章描述了实验结果，包括几个benchmark和TPC-C benchmark。最后一章总结和讨论了未来的一些工作。

## 2. 相关工作

在基于磁盘的数据库系统中，B+tree无所不在。他会一下子从磁盘读很多数据以避免对磁盘的读取次数。红黑树和T-Tree也被用过内存数据库的索引。Rao和Ross显示，T-tree，像很多二叉查找树一样，受限于严重的cache不友好的行为，在现代硬件上经常比B+Tree慢很多。作为一个备选，他们们提出了一个cache友好的B+Tree变种，被称为CSB+Tree。更多的针对B+Tree的cache优化是Graefe和Larson做的。

现代CPU通过一个SIMD指令可以同时做多个比较操作。Schlegel et al.提出了K路查找，减少了比较次数从O(log2n)到O(logkn)，k是一个SIMD vector能容纳的key的数量。同二叉树相比，这个技术可以减少cache miss的次数，因为K次比较是同时在每条从主存中load到cache line上执行的。Kim et al.提出的FAST扩展了这个研究，一个架构敏感的方式来存放二叉树的技术。SIMD，cache line，page blocking都被用来优化cache和内存带宽。另外，为了提高搜索算法的吞吐，他们提出插入多级流水线的查询。FAST树和K路查找树是没有指针的搜索数据结构，他们把所有的key存在一个数组里，然后用offset计算来遍历整棵树。尽管这种方式是查询快和节省空间的，但他也暗示了在线的插入是不可能的。Kim et al. 也提出了一个GPU的FAST实现，以及把它的性能和现代CPU做对比。结果显示，由于更高的内存带宽，GPU可以得到比CPU更多的吞吐。尽管如此，因为GPU的内存容量受限，同主存的通信成本很高，需要用几百个并行的查询来得到较高的吞吐，所以GPU作为索引硬件来使用不是特别实用。我们就把注意力集中在CPU的索引架构上来。

tries被用来索引字符串类型已经被研究的很广泛了。两个最早的变体用列表或者数组来做内部节点的形式。为了更有效的存储长string，Morrison提出了路径压缩的方法。Knuth很早就分析了这些trie变体。burst trie是一个更新一点的提议，树的高层节点用trie node，一但子元素数量少于某个数时就切换为链表。HAT-trie通过把链表切换为哈希表来提高性能。当大部分研究还在聚焦于索引字符串时，我们的目标是还能索引其他类型。所以相较于trie，我们更倾向于radix tree，因为它强调了排序算法的相似性和任意的数据都可以被索引。

Boehm et al. 首次提出了前缀树作为一个通用的检索结构。在SIGMOD Programming Contest 2009提出了一个fanout 16的radix tree。KISS-Tree是一个更有效的radix tree，它只有三层，却能存储32位的key。他用key的前16位和虚拟内存系统来节省存储空间。第二层用接下来的10位作为一个数组，最后一层用一个bit vector来压缩。Hewlett-Packard研究实验室发明的Judy数组数据类型可以动态改变内部节点。

Graefe讨论了可以二进制比较的key，作为一个简化和加速key比较的方法。我们用这些概念取得了radix tree里存储的key的顺序。

## 3. ADAPTIVE RADIX TREE

本章表述了Adaptive Radix Tree(ART)。我们基于一些在radix tree相较于比较树的优势开始。接下来我们说明了自适应的节点是必要的，因为传统的radix tree的空间占用非常显著。然后我们继续陈述了ART的查询和插入算法。最后我们分析了空间占用。

#### A 开场白
Radix tree有很多有趣的属性使他们和比较的搜索树完全不同：

1. Radix tree的高度和复杂度基于key的长度而不是元素的数目
2. Radix tree没有rebalance的操作，所有的插入顺序都会有同样的结果
3. key基于字典序来存储
4. 叶子节点的路径代表了叶子的key。所以key可以用路径来重建出来

Radix tree包含了两种类型的节点：内部节点，通过key的一部分指向另外的节点；叶子节点，存储了相应key的数据。内部节点最有效的方式是一个2^s大小的数组。在树的遍历中，key的s位的一块作为数组中的索引，这样不用任何比较就可以找到下一个节点。参数s，我们成为span，对radix tree的性能来说非常重要，
